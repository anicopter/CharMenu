   1               		.file	"CharMenu.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.rodata.str1.1,"aMS",@progbits,1
  11               	.LC0:
  12 0000 2000      		.string	" "
  13               	.LC1:
  14 0002 2564 00   		.string	"%d"
  15               		.text
  16               	.global	DrawNumber
  18               	DrawNumber:
  19               	.LFB7:
  20               		.file 1 "CharMenu.c"
   1:CharMenu.c    **** /**
   2:CharMenu.c    ****  * (c) 2014-2015 Izzulmakin
   3:CharMenu.c    ****  * made from 23 Dec 2014 based on makin.h (github.com/imakin/sarjiya)
   4:CharMenu.c    ****  * released under LGPL license, derivative works are bind to use LGPL license
   5:CharMenu.c    ****  */
   6:CharMenu.c    **** #include "CharMenu.h"
   7:CharMenu.c    **** #include <stdio.h>
   8:CharMenu.c    **** #include <string.h>
   9:CharMenu.c    **** #include <avr/io.h>
  10:CharMenu.c    **** #include "lcd_lib.h"
  11:CharMenu.c    **** #include <util/delay.h>
  12:CharMenu.c    **** 
  13:CharMenu.c    **** 
  14:CharMenu.c    **** void DrawNumber(uint16_t bil, uint8_t x, uint8_t y,uint8_t _c)
  15:CharMenu.c    **** {
  21               		.loc 1 15 0
  22               		.cfi_startproc
  23               	.LVL0:
  24 0000 CF92      		push r12
  25               	.LCFI0:
  26               		.cfi_def_cfa_offset 3
  27               		.cfi_offset 12, -2
  28 0002 DF92      		push r13
  29               	.LCFI1:
  30               		.cfi_def_cfa_offset 4
  31               		.cfi_offset 13, -3
  32 0004 EF92      		push r14
  33               	.LCFI2:
  34               		.cfi_def_cfa_offset 5
  35               		.cfi_offset 14, -4
  36 0006 FF92      		push r15
  37               	.LCFI3:
  38               		.cfi_def_cfa_offset 6
  39               		.cfi_offset 15, -5
  40 0008 0F93      		push r16
  41               	.LCFI4:
  42               		.cfi_def_cfa_offset 7
  43               		.cfi_offset 16, -6
  44 000a 1F93      		push r17
  45               	.LCFI5:
  46               		.cfi_def_cfa_offset 8
  47               		.cfi_offset 17, -7
  48 000c CF93      		push r28
  49               	.LCFI6:
  50               		.cfi_def_cfa_offset 9
  51               		.cfi_offset 28, -8
  52 000e DF93      		push r29
  53               	.LCFI7:
  54               		.cfi_def_cfa_offset 10
  55               		.cfi_offset 29, -9
  56 0010 CDB7      		in r28,__SP_L__
  57 0012 DEB7      		in r29,__SP_H__
  58               	.LCFI8:
  59               		.cfi_def_cfa_register 28
  60 0014 6E97      		sbiw r28,30
  61               	.LCFI9:
  62               		.cfi_def_cfa_offset 40
  63 0016 0FB6      		in __tmp_reg__,__SREG__
  64 0018 F894      		cli
  65 001a DEBF      		out __SP_H__,r29
  66 001c 0FBE      		out __SREG__,__tmp_reg__
  67 001e CDBF      		out __SP_L__,r28
  68               	/* prologue: function */
  69               	/* frame size = 30 */
  70               	/* stack size = 38 */
  71               	.L__stack_usage = 38
  72 0020 D82E      		mov r13,r24
  73 0022 C92E      		mov r12,r25
  74 0024 062F      		mov r16,r22
  75 0026 F42E      		mov r15,r20
  76 0028 E22E      		mov r14,r18
  16:CharMenu.c    **** 	uint8_t pjg;
  17:CharMenu.c    **** 	char lcdchar[30];
  18:CharMenu.c    **** 			LCDGotoXY(x,y);
  77               		.loc 1 18 0
  78 002a 642F      		mov r22,r20
  79               	.LVL1:
  80 002c 802F      		mov r24,r16
  81               	.LVL2:
  82 002e 0E94 0000 		call LCDGotoXY
  83               	.LVL3:
  19:CharMenu.c    **** 			if (_c!=0)
  84               		.loc 1 19 0
  85 0032 EE20      		tst r14
  86 0034 01F0      		breq .L2
  87 0036 11E0      		ldi r17,lo8(1)
  88               	.L3:
  89               	.LVL4:
  90               	.LBB4:
  20:CharMenu.c    **** 			{
  21:CharMenu.c    **** 				
  22:CharMenu.c    **** 				for (uint8_t i=1; i<=_c; i++)
  91               		.loc 1 22 0 discriminator 1
  92 0038 E116      		cp r14,r17
  93 003a 00F0      		brlo .L9
  23:CharMenu.c    **** 				{
  24:CharMenu.c    **** 					LCDstring((uint8_t*)" ",1);
  94               		.loc 1 24 0 discriminator 2
  95 003c 61E0      		ldi r22,lo8(1)
  96 003e 80E0      		ldi r24,lo8(.LC0)
  97 0040 90E0      		ldi r25,hi8(.LC0)
  98 0042 0E94 0000 		call LCDstring
  99               	.LVL5:
  22:CharMenu.c    **** 				for (uint8_t i=1; i<=_c; i++)
 100               		.loc 1 22 0 discriminator 2
 101 0046 1F5F      		subi r17,lo8(-(1))
 102               	.LVL6:
 103 0048 00C0      		rjmp .L3
 104               	.L9:
 105               	.LBE4:
  25:CharMenu.c    **** 				}
  26:CharMenu.c    **** 				LCDGotoXY(x,y);
 106               		.loc 1 26 0
 107 004a 6F2D      		mov r22,r15
 108 004c 802F      		mov r24,r16
 109 004e 0E94 0000 		call LCDGotoXY
 110               	.LVL7:
 111               	.L2:
  27:CharMenu.c    **** 			}
  28:CharMenu.c    **** 			snprintf(lcdchar,15, "%d",bil);
 112               		.loc 1 28 0
 113 0052 CF92      		push r12
 114 0054 DF92      		push r13
 115 0056 80E0      		ldi r24,lo8(.LC1)
 116 0058 90E0      		ldi r25,hi8(.LC1)
 117 005a 9F93      		push r25
 118 005c 8F93      		push r24
 119 005e 1F92      		push __zero_reg__
 120 0060 8FE0      		ldi r24,lo8(15)
 121 0062 8F93      		push r24
 122 0064 8E01      		movw r16,r28
 123               	.LVL8:
 124 0066 0F5F      		subi r16,-1
 125 0068 1F4F      		sbci r17,-1
 126 006a 1F93      		push r17
 127 006c 0F93      		push r16
 128 006e 0E94 0000 		call snprintf
 129               	.LVL9:
  29:CharMenu.c    **** 			pjg = strlen(lcdchar);
 130               		.loc 1 29 0
 131 0072 F801      		movw r30,r16
 132               		0:
 133 0074 0190      		ld __tmp_reg__,Z+
 134 0076 0020      		tst __tmp_reg__
 135 0078 01F4      		brne 0b
 136 007a BF01      		movw r22,r30
 137 007c 6150      		subi r22,1
 138 007e 7109      		sbc r23,__zero_reg__
 139 0080 601B      		sub r22,r16
 140 0082 710B      		sbc r23,r17
 141               	.LVL10:
  30:CharMenu.c    **** 			LCDstring((uint8_t*)lcdchar,pjg);
 142               		.loc 1 30 0
 143 0084 C801      		movw r24,r16
 144 0086 0E94 0000 		call LCDstring
 145               	.LVL11:
 146 008a 0FB6      		in __tmp_reg__,__SREG__
 147 008c F894      		cli
 148 008e DEBF      		out __SP_H__,r29
 149 0090 0FBE      		out __SREG__,__tmp_reg__
 150 0092 CDBF      		out __SP_L__,r28
 151               	/* epilogue start */
  31:CharMenu.c    **** 	
  32:CharMenu.c    **** }
 152               		.loc 1 32 0
 153 0094 6E96      		adiw r28,30
 154 0096 0FB6      		in __tmp_reg__,__SREG__
 155 0098 F894      		cli
 156 009a DEBF      		out __SP_H__,r29
 157 009c 0FBE      		out __SREG__,__tmp_reg__
 158 009e CDBF      		out __SP_L__,r28
 159 00a0 DF91      		pop r29
 160 00a2 CF91      		pop r28
 161 00a4 1F91      		pop r17
 162 00a6 0F91      		pop r16
 163 00a8 FF90      		pop r15
 164               	.LVL12:
 165 00aa EF90      		pop r14
 166               	.LVL13:
 167 00ac DF90      		pop r13
 168 00ae CF90      		pop r12
 169 00b0 0895      		ret
 170               		.cfi_endproc
 171               	.LFE7:
 173               	.global	DrawNumberCPos
 175               	DrawNumberCPos:
 176               	.LFB8:
  33:CharMenu.c    **** ///
  34:CharMenu.c    **** void DrawNumberCPos(uint16_t bil, uint8_t _c)
  35:CharMenu.c    **** {
 177               		.loc 1 35 0
 178               		.cfi_startproc
 179               	.LVL14:
 180 00b2 EF92      		push r14
 181               	.LCFI10:
 182               		.cfi_def_cfa_offset 3
 183               		.cfi_offset 14, -2
 184 00b4 FF92      		push r15
 185               	.LCFI11:
 186               		.cfi_def_cfa_offset 4
 187               		.cfi_offset 15, -3
 188 00b6 0F93      		push r16
 189               	.LCFI12:
 190               		.cfi_def_cfa_offset 5
 191               		.cfi_offset 16, -4
 192 00b8 1F93      		push r17
 193               	.LCFI13:
 194               		.cfi_def_cfa_offset 6
 195               		.cfi_offset 17, -5
 196 00ba CF93      		push r28
 197               	.LCFI14:
 198               		.cfi_def_cfa_offset 7
 199               		.cfi_offset 28, -6
 200 00bc DF93      		push r29
 201               	.LCFI15:
 202               		.cfi_def_cfa_offset 8
 203               		.cfi_offset 29, -7
 204 00be CDB7      		in r28,__SP_L__
 205 00c0 DEB7      		in r29,__SP_H__
 206               	.LCFI16:
 207               		.cfi_def_cfa_register 28
 208 00c2 6E97      		sbiw r28,30
 209               	.LCFI17:
 210               		.cfi_def_cfa_offset 38
 211 00c4 0FB6      		in __tmp_reg__,__SREG__
 212 00c6 F894      		cli
 213 00c8 DEBF      		out __SP_H__,r29
 214 00ca 0FBE      		out __SREG__,__tmp_reg__
 215 00cc CDBF      		out __SP_L__,r28
 216               	/* prologue: function */
 217               	/* frame size = 30 */
 218               	/* stack size = 36 */
 219               	.L__stack_usage = 36
 220 00ce F82E      		mov r15,r24
 221 00d0 E92E      		mov r14,r25
 222 00d2 062F      		mov r16,r22
  36:CharMenu.c    **** 	uint8_t pjg;
  37:CharMenu.c    **** 	char lcdchar[30];
  38:CharMenu.c    **** 	if (_c!=0)
 223               		.loc 1 38 0
 224 00d4 6111      		cpse r22,__zero_reg__
 225 00d6 00C0      		rjmp .L11
 226               	.LVL15:
 227               	.L14:
  39:CharMenu.c    **** 	{
  40:CharMenu.c    **** 		
  41:CharMenu.c    **** 		for (uint8_t i=1; i<=_c; i++)
  42:CharMenu.c    **** 		{
  43:CharMenu.c    **** 			LCDstring((uint8_t*)" ",1);
  44:CharMenu.c    **** 		}
  45:CharMenu.c    **** 	}
  46:CharMenu.c    **** 	snprintf(lcdchar,15, "%d",bil);
 228               		.loc 1 46 0
 229 00d8 EF92      		push r14
 230 00da FF92      		push r15
 231 00dc 80E0      		ldi r24,lo8(.LC1)
 232 00de 90E0      		ldi r25,hi8(.LC1)
 233 00e0 9F93      		push r25
 234 00e2 8F93      		push r24
 235 00e4 1F92      		push __zero_reg__
 236 00e6 8FE0      		ldi r24,lo8(15)
 237 00e8 8F93      		push r24
 238 00ea 8E01      		movw r16,r28
 239               	.LVL16:
 240 00ec 0F5F      		subi r16,-1
 241 00ee 1F4F      		sbci r17,-1
 242 00f0 1F93      		push r17
 243 00f2 0F93      		push r16
 244 00f4 0E94 0000 		call snprintf
 245               	.LVL17:
  47:CharMenu.c    **** 	pjg = strlen(lcdchar);
 246               		.loc 1 47 0
 247 00f8 F801      		movw r30,r16
 248               		0:
 249 00fa 0190      		ld __tmp_reg__,Z+
 250 00fc 0020      		tst __tmp_reg__
 251 00fe 01F4      		brne 0b
 252 0100 BF01      		movw r22,r30
 253 0102 6150      		subi r22,1
 254 0104 7109      		sbc r23,__zero_reg__
 255 0106 601B      		sub r22,r16
 256 0108 710B      		sbc r23,r17
 257               	.LVL18:
  48:CharMenu.c    **** 	LCDstring((uint8_t*)lcdchar,pjg);
 258               		.loc 1 48 0
 259 010a C801      		movw r24,r16
 260 010c 0E94 0000 		call LCDstring
 261               	.LVL19:
  49:CharMenu.c    **** 	
  50:CharMenu.c    **** }
 262               		.loc 1 50 0
 263 0110 0FB6      		in __tmp_reg__,__SREG__
 264 0112 F894      		cli
 265 0114 DEBF      		out __SP_H__,r29
 266 0116 0FBE      		out __SREG__,__tmp_reg__
 267 0118 CDBF      		out __SP_L__,r28
 268               	/* epilogue start */
 269 011a 6E96      		adiw r28,30
 270 011c 0FB6      		in __tmp_reg__,__SREG__
 271 011e F894      		cli
 272 0120 DEBF      		out __SP_H__,r29
 273 0122 0FBE      		out __SREG__,__tmp_reg__
 274 0124 CDBF      		out __SP_L__,r28
 275 0126 DF91      		pop r29
 276 0128 CF91      		pop r28
 277 012a 1F91      		pop r17
 278 012c 0F91      		pop r16
 279 012e FF90      		pop r15
 280 0130 EF90      		pop r14
 281 0132 0895      		ret
 282               	.LVL20:
 283               	.L11:
  38:CharMenu.c    **** 	if (_c!=0)
 284               		.loc 1 38 0
 285 0134 11E0      		ldi r17,lo8(1)
 286               	.LVL21:
 287               	.L12:
 288               	.LBB5:
  41:CharMenu.c    **** 		for (uint8_t i=1; i<=_c; i++)
 289               		.loc 1 41 0 discriminator 1
 290 0136 0117      		cp r16,r17
 291 0138 00F0      		brlo .L14
  43:CharMenu.c    **** 			LCDstring((uint8_t*)" ",1);
 292               		.loc 1 43 0 discriminator 2
 293 013a 61E0      		ldi r22,lo8(1)
 294 013c 80E0      		ldi r24,lo8(.LC0)
 295 013e 90E0      		ldi r25,hi8(.LC0)
 296 0140 0E94 0000 		call LCDstring
 297               	.LVL22:
  41:CharMenu.c    **** 		for (uint8_t i=1; i<=_c; i++)
 298               		.loc 1 41 0 discriminator 2
 299 0144 1F5F      		subi r17,lo8(-(1))
 300               	.LVL23:
 301 0146 00C0      		rjmp .L12
 302               	.LBE5:
 303               		.cfi_endproc
 304               	.LFE8:
 306               	.global	LcdDelete
 308               	LcdDelete:
 309               	.LFB9:
  51:CharMenu.c    **** 
  52:CharMenu.c    **** ///Clears block with whitespace replacing
  53:CharMenu.c    **** void LcdDelete(uint8_t xawal, uint8_t xakhir, uint8_t _Y)
  54:CharMenu.c    **** {
 310               		.loc 1 54 0
 311               		.cfi_startproc
 312               	.LVL24:
 313 0148 CF93      		push r28
 314               	.LCFI18:
 315               		.cfi_def_cfa_offset 3
 316               		.cfi_offset 28, -2
 317 014a DF93      		push r29
 318               	.LCFI19:
 319               		.cfi_def_cfa_offset 4
 320               		.cfi_offset 29, -3
 321               	/* prologue: function */
 322               	/* frame size = 0 */
 323               	/* stack size = 2 */
 324               	.L__stack_usage = 2
 325 014c C82F      		mov r28,r24
 326 014e D62F      		mov r29,r22
  55:CharMenu.c    **** 	LCDGotoXY(xawal,_Y);
 327               		.loc 1 55 0
 328 0150 642F      		mov r22,r20
 329               	.LVL25:
 330 0152 0E94 0000 		call LCDGotoXY
 331               	.LVL26:
 332               	.L17:
 333               	.LBB6:
  56:CharMenu.c    **** 	for (uint8_t i=xawal;i<=xakhir;i++)
 334               		.loc 1 56 0 discriminator 1
 335 0156 DC17      		cp r29,r28
 336 0158 00F0      		brlo .L19
  57:CharMenu.c    **** 	{
  58:CharMenu.c    **** 		LCDstring((uint8_t*)" ",1);
 337               		.loc 1 58 0 discriminator 2
 338 015a 61E0      		ldi r22,lo8(1)
 339 015c 80E0      		ldi r24,lo8(.LC0)
 340 015e 90E0      		ldi r25,hi8(.LC0)
 341 0160 0E94 0000 		call LCDstring
 342               	.LVL27:
  56:CharMenu.c    **** 	for (uint8_t i=xawal;i<=xakhir;i++)
 343               		.loc 1 56 0 discriminator 2
 344 0164 CF5F      		subi r28,lo8(-(1))
 345               	.LVL28:
 346 0166 00C0      		rjmp .L17
 347               	.L19:
 348               	/* epilogue start */
 349               	.LBE6:
  59:CharMenu.c    **** 	}
  60:CharMenu.c    **** }
 350               		.loc 1 60 0
 351 0168 DF91      		pop r29
 352               	.LVL29:
 353 016a CF91      		pop r28
 354               	.LVL30:
 355 016c 0895      		ret
 356               		.cfi_endproc
 357               	.LFE9:
 359               	.global	ButtonEnter
 361               	ButtonEnter:
 362               	.LFB10:
  61:CharMenu.c    **** 
  62:CharMenu.c    **** 
  63:CharMenu.c    **** /**  return is it true that particular button is pressed (Enter, Back, Next, Prev)*/
  64:CharMenu.c    **** uint8_t ButtonEnter()
  65:CharMenu.c    **** {
 363               		.loc 1 65 0
 364               		.cfi_startproc
 365               	/* prologue: function */
 366               	/* frame size = 0 */
 367               	/* stack size = 0 */
 368               	.L__stack_usage = 0
  66:CharMenu.c    **** 	return isclear(BUTTON_ENTER_PIN,BUTTON_ENTER_DOWN);
 369               		.loc 1 66 0
 370 016e 83B3      		in r24,0x13
 371 0170 8695      		lsr r24
 372 0172 8170      		andi r24,1
  67:CharMenu.c    **** }
 373               		.loc 1 67 0
 374 0174 91E0      		ldi r25,lo8(1)
 375 0176 8927      		eor r24,r25
 376 0178 0895      		ret
 377               		.cfi_endproc
 378               	.LFE10:
 380               	.global	ButtonBack
 382               	ButtonBack:
 383               	.LFB11:
  68:CharMenu.c    **** uint8_t ButtonBack()
  69:CharMenu.c    **** {
 384               		.loc 1 69 0
 385               		.cfi_startproc
 386               	/* prologue: function */
 387               	/* frame size = 0 */
 388               	/* stack size = 0 */
 389               	.L__stack_usage = 0
  70:CharMenu.c    **** 	return isclear(BUTTON_BACK_PIN,BUTTON_BACK_DOWN);
 390               		.loc 1 70 0
 391 017a 83B3      		in r24,0x13
 392 017c 82FB      		bst r24,2
 393 017e 8827      		clr r24
 394 0180 80F9      		bld r24,0
  71:CharMenu.c    **** }
 395               		.loc 1 71 0
 396 0182 91E0      		ldi r25,lo8(1)
 397 0184 8927      		eor r24,r25
 398 0186 0895      		ret
 399               		.cfi_endproc
 400               	.LFE11:
 402               	.global	ButtonNext
 404               	ButtonNext:
 405               	.LFB12:
  72:CharMenu.c    **** uint8_t ButtonNext()
  73:CharMenu.c    **** {
 406               		.loc 1 73 0
 407               		.cfi_startproc
 408               	/* prologue: function */
 409               	/* frame size = 0 */
 410               	/* stack size = 0 */
 411               	.L__stack_usage = 0
  74:CharMenu.c    **** 	return isclear(BUTTON_NEXT_PIN,BUTTON_NEXT_DOWN);
 412               		.loc 1 74 0
 413 0188 83B3      		in r24,0x13
 414 018a 83FB      		bst r24,3
 415 018c 8827      		clr r24
 416 018e 80F9      		bld r24,0
  75:CharMenu.c    **** }
 417               		.loc 1 75 0
 418 0190 91E0      		ldi r25,lo8(1)
 419 0192 8927      		eor r24,r25
 420 0194 0895      		ret
 421               		.cfi_endproc
 422               	.LFE12:
 424               	.global	ButtonPrev
 426               	ButtonPrev:
 427               	.LFB13:
  76:CharMenu.c    **** uint8_t ButtonPrev()
  77:CharMenu.c    **** {
 428               		.loc 1 77 0
 429               		.cfi_startproc
 430               	/* prologue: function */
 431               	/* frame size = 0 */
 432               	/* stack size = 0 */
 433               	.L__stack_usage = 0
  78:CharMenu.c    **** 	return isclear(BUTTON_PREV_PIN,BUTTON_PREV_DOWN);
 434               		.loc 1 78 0
 435 0196 83B3      		in r24,0x13
 436 0198 8095      		com r24
  79:CharMenu.c    **** }
 437               		.loc 1 79 0
 438 019a 8170      		andi r24,lo8(1)
 439 019c 0895      		ret
 440               		.cfi_endproc
 441               	.LFE13:
 443               	.global	ButtonWait
 445               	ButtonWait:
 446               	.LFB14:
  80:CharMenu.c    **** 
  81:CharMenu.c    **** 
  82:CharMenu.c    **** 
  83:CharMenu.c    **** void ButtonWait()
  84:CharMenu.c    **** {
 447               		.loc 1 84 0
 448               		.cfi_startproc
 449               	/* prologue: function */
 450               	/* frame size = 0 */
 451               	/* stack size = 0 */
 452               	.L__stack_usage = 0
 453               	.L26:
  85:CharMenu.c    **** 	/** Let the system pause and wait for any button to be pressed */
  86:CharMenu.c    **** 	while (isset(BUTTON_ENTER_PIN,BUTTON_ENTER_DOWN) && isset(BUTTON_BACK_PIN,BUTTON_BACK_DOWN) && iss
 454               		.loc 1 86 0 discriminator 1
 455 019e 999B      		sbis 0x13,1
 456 01a0 00C0      		rjmp .L24
 457               		.loc 1 86 0 is_stmt 0 discriminator 2
 458 01a2 9A9B      		sbis 0x13,2
 459 01a4 00C0      		rjmp .L24
 460               		.loc 1 86 0 discriminator 1
 461 01a6 9B9B      		sbis 0x13,3
 462 01a8 00C0      		rjmp .L24
 463 01aa 9899      		sbic 0x13,0
 464 01ac 00C0      		rjmp .L26
 465               	.L24:
 466 01ae 0895      		ret
 467               		.cfi_endproc
 468               	.LFE14:
 470               	.global	ButtonIsPressed
 472               	ButtonIsPressed:
 473               	.LFB15:
  87:CharMenu.c    **** }
  88:CharMenu.c    **** uint8_t ButtonIsPressed()
  89:CharMenu.c    **** {
 474               		.loc 1 89 0 is_stmt 1
 475               		.cfi_startproc
 476               	/* prologue: function */
 477               	/* frame size = 0 */
 478               	/* stack size = 0 */
 479               	.L__stack_usage = 0
  90:CharMenu.c    **** 	/** Check if there are (any) button pressed */
  91:CharMenu.c    **** 	return (isclear(BUTTON_ENTER_PIN,BUTTON_ENTER_DOWN) || isclear(BUTTON_BACK_PIN,BUTTON_BACK_DOWN) |
 480               		.loc 1 91 0
 481 01b0 999B      		sbis 0x13,1
 482 01b2 00C0      		rjmp .L43
 483               		.loc 1 91 0 is_stmt 0 discriminator 2
 484 01b4 9A9B      		sbis 0x13,2
 485 01b6 00C0      		rjmp .L43
 486               		.loc 1 91 0 discriminator 1
 487 01b8 9B9B      		sbis 0x13,3
 488 01ba 00C0      		rjmp .L43
 489 01bc 83B3      		in r24,0x13
 490 01be 8095      		com r24
 491 01c0 8170      		andi r24,lo8(1)
 492 01c2 0895      		ret
 493               	.L43:
 494               		.loc 1 91 0
 495 01c4 81E0      		ldi r24,lo8(1)
  92:CharMenu.c    **** }
 496               		.loc 1 92 0 is_stmt 1
 497 01c6 0895      		ret
 498               		.cfi_endproc
 499               	.LFE15:
 501               	.global	ButtonIsNotPressed
 503               	ButtonIsNotPressed:
 504               	.LFB16:
  93:CharMenu.c    **** uint8_t ButtonIsNotPressed()
  94:CharMenu.c    **** {
 505               		.loc 1 94 0
 506               		.cfi_startproc
 507               	/* prologue: function */
 508               	/* frame size = 0 */
 509               	/* stack size = 0 */
 510               	.L__stack_usage = 0
  95:CharMenu.c    **** 	/** Check if all button is currently not pressed */
  96:CharMenu.c    **** 	return (isset(BUTTON_ENTER_PIN,BUTTON_ENTER_DOWN) || isset(BUTTON_BACK_PIN,BUTTON_BACK_DOWN) || is
 511               		.loc 1 96 0
 512 01c8 9999      		sbic 0x13,1
 513 01ca 00C0      		rjmp .L48
 514               		.loc 1 96 0 is_stmt 0 discriminator 2
 515 01cc 9A99      		sbic 0x13,2
 516 01ce 00C0      		rjmp .L48
 517               		.loc 1 96 0 discriminator 1
 518 01d0 9B99      		sbic 0x13,3
 519 01d2 00C0      		rjmp .L48
 520 01d4 83B3      		in r24,0x13
 521 01d6 8170      		andi r24,lo8(1)
 522 01d8 0895      		ret
 523               	.L48:
 524               		.loc 1 96 0
 525 01da 81E0      		ldi r24,lo8(1)
  97:CharMenu.c    **** }
 526               		.loc 1 97 0 is_stmt 1
 527 01dc 0895      		ret
 528               		.cfi_endproc
 529               	.LFE16:
 531               	.global	ButtonRead
 533               	ButtonRead:
 534               	.LFB17:
  98:CharMenu.c    **** uint8_t ButtonRead()
  99:CharMenu.c    **** {
 535               		.loc 1 99 0
 536               		.cfi_startproc
 537               	/* prologue: function */
 538               	/* frame size = 0 */
 539               	/* stack size = 0 */
 540               	.L__stack_usage = 0
 100:CharMenu.c    **** 	/** Wait for any button to be pressed and return which button is pressed */
 101:CharMenu.c    **** 	uint8_t output;
 102:CharMenu.c    **** 	ButtonWait();
 541               		.loc 1 102 0
 542 01de 0E94 0000 		call ButtonWait
 543               	.LVL31:
 103:CharMenu.c    **** 	if (isclear(BUTTON_ENTER_PIN,BUTTON_ENTER_DOWN))
 544               		.loc 1 103 0
 545 01e2 999B      		sbis 0x13,1
 546 01e4 00C0      		rjmp .L51
 104:CharMenu.c    **** 		output = BUTTON_ENTER_DOWN;
 105:CharMenu.c    **** 	else if (isclear(BUTTON_BACK_PIN,BUTTON_BACK_DOWN))
 547               		.loc 1 105 0
 548 01e6 9A9B      		sbis 0x13,2
 549 01e8 00C0      		rjmp .L52
 106:CharMenu.c    **** 		output = BUTTON_BACK_DOWN;
 107:CharMenu.c    **** 	else if (isclear(BUTTON_NEXT_PIN,BUTTON_NEXT_DOWN))
 550               		.loc 1 107 0
 551 01ea 9B99      		sbic 0x13,3
 552 01ec 00C0      		rjmp .L53
 108:CharMenu.c    **** 		output = BUTTON_NEXT_DOWN;
 553               		.loc 1 108 0
 554 01ee 83E0      		ldi r24,lo8(3)
 555 01f0 00C0      		rjmp .L50
 556               	.L51:
 104:CharMenu.c    **** 		output = BUTTON_ENTER_DOWN;
 557               		.loc 1 104 0
 558 01f2 81E0      		ldi r24,lo8(1)
 559 01f4 00C0      		rjmp .L50
 560               	.L52:
 106:CharMenu.c    **** 		output = BUTTON_BACK_DOWN;
 561               		.loc 1 106 0
 562 01f6 82E0      		ldi r24,lo8(2)
 563 01f8 00C0      		rjmp .L50
 564               	.L53:
 109:CharMenu.c    **** 	else 
 110:CharMenu.c    **** 		output = BUTTON_PREV_DOWN;
 565               		.loc 1 110 0
 566 01fa 80E0      		ldi r24,0
 567               	.L50:
 568               	.LVL32:
 569               	.LBB7:
 570               	.LBB8:
 571               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 572               		.loc 2 164 0
 573 01fc 2FE7      		ldi r18,lo8(239999)
 574 01fe 39EA      		ldi r19,hi8(239999)
 575 0200 93E0      		ldi r25,hlo8(239999)
 576 0202 2150      		1: subi r18,1
 577 0204 3040      		sbci r19,0
 578 0206 9040      		sbci r25,0
 579 0208 01F4      		brne 1b
 580 020a 00C0      		rjmp .
 581 020c 0000      		nop
 582               	.LBE8:
 583               	.LBE7:
 111:CharMenu.c    **** 	_delay_ms(100);
 112:CharMenu.c    **** 	return (output);
 113:CharMenu.c    **** }
 584               		.loc 1 113 0
 585 020e 0895      		ret
 586               		.cfi_endproc
 587               	.LFE17:
 589               		.section	.rodata.str1.1
 590               	.LC2:
 591 0005 00        		.string	""
 592               		.text
 593               	.global	CharMenuInit
 595               	CharMenuInit:
 596               	.LFB18:
 114:CharMenu.c    **** 
 115:CharMenu.c    **** void CharMenuInit()
 116:CharMenu.c    **** {
 597               		.loc 1 116 0
 598               		.cfi_startproc
 599               	/* prologue: function */
 600               	/* frame size = 0 */
 601               	/* stack size = 0 */
 602               	.L__stack_usage = 0
 117:CharMenu.c    **** 	MenuMain[0].cursorNum = 1;
 603               		.loc 1 117 0
 604 0210 81E0      		ldi r24,lo8(1)
 605 0212 90E0      		ldi r25,0
 606 0214 9093 0000 		sts MenuMain+1,r25
 607 0218 8093 0000 		sts MenuMain,r24
 118:CharMenu.c    **** 	MenuMain[0].menuText = (uint8_t*)"";//main menu text will not be used
 608               		.loc 1 118 0
 609 021c 80E0      		ldi r24,lo8(.LC2)
 610 021e 90E0      		ldi r25,hi8(.LC2)
 611 0220 9093 0000 		sts MenuMain+2+1,r25
 612 0224 8093 0000 		sts MenuMain+2,r24
 119:CharMenu.c    **** 	MenuMain[0].numOfChildren = MAIN_MENU_NUMBER_OF_CHILDREN;
 613               		.loc 1 119 0
 614 0228 82E0      		ldi r24,lo8(2)
 615 022a 8093 0000 		sts MenuMain+4,r24
 120:CharMenu.c    **** 	MenuMain[0].parentIndex = 0;
 616               		.loc 1 120 0
 617 022e 1092 0000 		sts MenuMain+5,__zero_reg__
 121:CharMenu.c    **** 	MenuMain[0].actFunction = 0;
 618               		.loc 1 121 0
 619 0232 1092 0000 		sts MenuMain+6+1,__zero_reg__
 620 0236 1092 0000 		sts MenuMain+6,__zero_reg__
 122:CharMenu.c    **** 	
 123:CharMenu.c    **** 	BUTTON_ENTER_PORT |= (1<<BUTTON_ENTER_DOWN);
 621               		.loc 1 123 0
 622 023a A99A      		sbi 0x15,1
 124:CharMenu.c    **** 	BUTTON_BACK_PORT |= (1<<BUTTON_BACK_DOWN);
 623               		.loc 1 124 0
 624 023c AA9A      		sbi 0x15,2
 125:CharMenu.c    **** 	BUTTON_NEXT_PORT |= (1<<BUTTON_NEXT_DOWN);
 625               		.loc 1 125 0
 626 023e AB9A      		sbi 0x15,3
 126:CharMenu.c    **** 	BUTTON_PREV_PORT |= (1<<BUTTON_PREV_DOWN);
 627               		.loc 1 126 0
 628 0240 A89A      		sbi 0x15,0
 629 0242 0895      		ret
 630               		.cfi_endproc
 631               	.LFE18:
 633               	.global	CharMenuRelink
 635               	CharMenuRelink:
 636               	.LFB19:
 127:CharMenu.c    **** }
 128:CharMenu.c    **** 
 129:CharMenu.c    **** void CharMenuRelink()
 130:CharMenu.c    **** {
 637               		.loc 1 130 0
 638               		.cfi_startproc
 639               	/* prologue: function */
 640               	/* frame size = 0 */
 641               	/* stack size = 0 */
 642               	.L__stack_usage = 0
 643               	.LVL33:
 644 0244 E0E0      		ldi r30,lo8(MenuMain+6)
 645 0246 F0E0      		ldi r31,hi8(MenuMain+6)
 646               	.LVL34:
 647               	.L57:
 131:CharMenu.c    **** 	uint8_t x=0;
 132:CharMenu.c    **** 	for (x=0;x<TOTAL_MENU;x++)
 133:CharMenu.c    **** 	{
 134:CharMenu.c    **** 		MenuMain[x].actFunction = 0;
 648               		.loc 1 134 0 discriminator 2
 649 0248 1182      		std Z+1,__zero_reg__
 650 024a 1082      		st Z,__zero_reg__
 651 024c 3896      		adiw r30,8
 132:CharMenu.c    **** 	for (x=0;x<TOTAL_MENU;x++)
 652               		.loc 1 132 0 discriminator 2
 653 024e 80E0      		ldi r24,hi8(MenuMain+94)
 654 0250 E030      		cpi r30,lo8(MenuMain+94)
 655 0252 F807      		cpc r31,r24
 656 0254 01F4      		brne .L57
 657               	/* epilogue start */
 135:CharMenu.c    **** 	}
 136:CharMenu.c    **** }
 658               		.loc 1 136 0
 659 0256 0895      		ret
 660               		.cfi_endproc
 661               	.LFE19:
 663               	.global	GetCursor
 665               	GetCursor:
 666               	.LFB21:
 137:CharMenu.c    **** 
 138:CharMenu.c    **** void CharMenuDraw()
 139:CharMenu.c    **** {
 140:CharMenu.c    **** 	if (MenuMain[gState].actFunction!=0)
 141:CharMenu.c    **** 	{
 142:CharMenu.c    **** 		MenuMain[gState].actFunction();
 143:CharMenu.c    **** 		//------------- Delay and button wait is now disabled, to let user pick wether to do delay and wa
 144:CharMenu.c    **** 		/**_delay_ms(500);
 145:CharMenu.c    **** 		while (!ButtonBack());**/
 146:CharMenu.c    **** 		gCursor = MenuMain[gState].cursorNum;
 147:CharMenu.c    **** 		gState = MenuMain[gState].parentIndex;
 148:CharMenu.c    **** 		return;
 149:CharMenu.c    **** 	}
 150:CharMenu.c    **** 	uint8_t x=0;
 151:CharMenu.c    **** 	///Catch the current menu and cursor, x start from 1 (not main menu)
 152:CharMenu.c    **** 	for (x=1;x<TOTAL_MENU;x++)
 153:CharMenu.c    **** 	{
 154:CharMenu.c    **** 		///current state is gState, find children of MenuMain[gState]
 155:CharMenu.c    **** 		if ((MenuMain[x].parentIndex == gState) && ((MenuMain[x].cursorNum) == gCursor))
 156:CharMenu.c    **** 		{
 157:CharMenu.c    **** 			///Draw the current menu at current cursor
 158:CharMenu.c    **** 			LCDGotoXY(0,0);
 159:CharMenu.c    **** 			LCDstring((uint8_t*)(MenuMain[x].menuText),16);
 160:CharMenu.c    **** 			PrintScroll(gCursor,MenuMain[MenuMain[x].parentIndex].numOfChildren);
 161:CharMenu.c    **** 			
 162:CharMenu.c    **** 			///wait signal
 163:CharMenu.c    **** 			uint8_t action = ButtonRead();
 164:CharMenu.c    **** 			if (action == BUTTON_ENTER_DOWN)
 165:CharMenu.c    **** 			{
 166:CharMenu.c    **** 				gState = x;
 167:CharMenu.c    **** 				gCursor = 1;
 168:CharMenu.c    **** 				//~ DrawNumber(gState,0,1,3);
 169:CharMenu.c    **** 				//~ uint8_t ii;
 170:CharMenu.c    **** 				//~ for (ii=1;ii<TOTAL_MENU;ii++)
 171:CharMenu.c    **** 				//~ {
 172:CharMenu.c    **** 					//~ if ((MenuMain[ii].parentIndex==x) && (MenuMain[ii].cursorNum==1))
 173:CharMenu.c    **** 					//~ {
 174:CharMenu.c    **** 						//~ gCursor = 1;
 175:CharMenu.c    **** 						//~ gState = ii;
 176:CharMenu.c    **** 						//~ break;
 177:CharMenu.c    **** 					//~ }
 178:CharMenu.c    **** 				//~ }
 179:CharMenu.c    **** 				//~ _delay_ms(1000);
 180:CharMenu.c    **** 			}
 181:CharMenu.c    **** 			else if (action == BUTTON_NEXT_DOWN)
 182:CharMenu.c    **** 			{
 183:CharMenu.c    **** 				gCursor++;
 184:CharMenu.c    **** 				if (gCursor>MenuMain[MenuMain[x].parentIndex].numOfChildren)
 185:CharMenu.c    **** 					gCursor = 1;
 186:CharMenu.c    **** 			}
 187:CharMenu.c    **** 			else if (action == BUTTON_PREV_DOWN)
 188:CharMenu.c    **** 			{
 189:CharMenu.c    **** 				gCursor--;
 190:CharMenu.c    **** 				if (gCursor<1)
 191:CharMenu.c    **** 					gCursor = MenuMain[MenuMain[x].parentIndex].numOfChildren;
 192:CharMenu.c    **** 			}
 193:CharMenu.c    **** 			else if (action == BUTTON_BACK_DOWN)
 194:CharMenu.c    **** 			{
 195:CharMenu.c    **** 				gCursor = MenuMain[gState].cursorNum;
 196:CharMenu.c    **** 				gState = MenuMain[gState].parentIndex;
 197:CharMenu.c    **** 				//~ DrawNumber(MenuMain[gState].cursorNum,3,1,2);
 198:CharMenu.c    **** 				//~ gCursor = 1;
 199:CharMenu.c    **** 				//~ return;
 200:CharMenu.c    **** 			}
 201:CharMenu.c    **** 			return;
 202:CharMenu.c    **** 		}
 203:CharMenu.c    **** 	}
 204:CharMenu.c    **** }
 205:CharMenu.c    **** 
 206:CharMenu.c    **** uint8_t GetCursor(uint16_t numstate)
 207:CharMenu.c    **** {
 667               		.loc 1 207 0
 668               		.cfi_startproc
 669               	.LVL35:
 670               	/* prologue: function */
 671               	/* frame size = 0 */
 672               	/* stack size = 0 */
 673               	.L__stack_usage = 0
 208:CharMenu.c    **** 	if (numstate>=20)
 674               		.loc 1 208 0
 675 0258 8431      		cpi r24,20
 676 025a 9105      		cpc r25,__zero_reg__
 677 025c 00F0      		brlo .L60
 209:CharMenu.c    **** 		return (numstate%10);
 678               		.loc 1 209 0
 679 025e 6AE0      		ldi r22,lo8(10)
 680 0260 70E0      		ldi r23,0
 681 0262 0E94 0000 		call __udivmodhi4
 682               	.LVL36:
 683               	.L60:
 210:CharMenu.c    **** 	return numstate;
 211:CharMenu.c    **** }
 684               		.loc 1 211 0
 685 0266 0895      		ret
 686               		.cfi_endproc
 687               	.LFE21:
 689               	.global	GetParent
 691               	GetParent:
 692               	.LFB22:
 212:CharMenu.c    **** uint8_t GetParent(uint16_t numstate)
 213:CharMenu.c    **** {
 693               		.loc 1 213 0
 694               		.cfi_startproc
 695               	.LVL37:
 696               	/* prologue: function */
 697               	/* frame size = 0 */
 698               	/* stack size = 0 */
 699               	.L__stack_usage = 0
 214:CharMenu.c    **** 	if (numstate<20)
 700               		.loc 1 214 0
 701 0268 8431      		cpi r24,20
 702 026a 9105      		cpc r25,__zero_reg__
 703 026c 00F0      		brlo .L63
 215:CharMenu.c    **** 		return 0;///its parent is menu
 216:CharMenu.c    **** 	return (numstate/10);
 704               		.loc 1 216 0
 705 026e 6AE0      		ldi r22,lo8(10)
 706 0270 70E0      		ldi r23,0
 707 0272 0E94 0000 		call __udivmodhi4
 708               	.LVL38:
 709 0276 862F      		mov r24,r22
 710 0278 0895      		ret
 711               	.LVL39:
 712               	.L63:
 215:CharMenu.c    **** 		return 0;///its parent is menu
 713               		.loc 1 215 0
 714 027a 80E0      		ldi r24,0
 715               	.LVL40:
 217:CharMenu.c    **** }
 716               		.loc 1 217 0
 717 027c 0895      		ret
 718               		.cfi_endproc
 719               	.LFE22:
 721               	.global	GetChild
 723               	GetChild:
 724               	.LFB23:
 218:CharMenu.c    **** uint8_t GetChild(uint8_t parent, uint8_t childid)
 219:CharMenu.c    **** {
 725               		.loc 1 219 0
 726               		.cfi_startproc
 727               	.LVL41:
 728               	/* prologue: function */
 729               	/* frame size = 0 */
 730               	/* stack size = 0 */
 731               	.L__stack_usage = 0
 220:CharMenu.c    **** 	return (parent*10)+childid;
 221:CharMenu.c    **** }
 732               		.loc 1 221 0
 733 027e 9AE0      		ldi r25,lo8(10)
 734 0280 899F      		mul r24,r25
 735 0282 600D      		add r22,r0
 736 0284 1124      		clr __zero_reg__
 737               	.LVL42:
 738 0286 862F      		mov r24,r22
 739               	.LVL43:
 740 0288 0895      		ret
 741               		.cfi_endproc
 742               	.LFE23:
 744               	.global	ReStrainScroll
 746               	ReStrainScroll:
 747               	.LFB24:
 222:CharMenu.c    **** 
 223:CharMenu.c    **** void ReStrainScroll()
 224:CharMenu.c    **** {
 748               		.loc 1 224 0
 749               		.cfi_startproc
 750               	/* prologue: function */
 751               	/* frame size = 0 */
 752               	/* stack size = 0 */
 753               	.L__stack_usage = 0
 225:CharMenu.c    **** 	if (gCursor<1)
 754               		.loc 1 225 0
 755 028a 9091 0000 		lds r25,gCursor
 756 028e 8091 0000 		lds r24,gScrollMax
 757 0292 9923      		tst r25
 758 0294 01F0      		breq .L68
 226:CharMenu.c    **** 	{
 227:CharMenu.c    **** 		gCursor = gScrollMax;
 228:CharMenu.c    **** 	}
 229:CharMenu.c    **** 	else if (gCursor>gScrollMax)
 759               		.loc 1 229 0
 760 0296 8917      		cp r24,r25
 761 0298 00F4      		brsh .L65
 230:CharMenu.c    **** 	{
 231:CharMenu.c    **** 		gCursor = 1;
 762               		.loc 1 231 0
 763 029a 81E0      		ldi r24,lo8(1)
 764               	.L68:
 765 029c 8093 0000 		sts gCursor,r24
 766               	.L65:
 767 02a0 0895      		ret
 768               		.cfi_endproc
 769               	.LFE24:
 771               	.global	PrintScroll
 773               	PrintScroll:
 774               	.LFB25:
 232:CharMenu.c    **** 	}
 233:CharMenu.c    **** }
 234:CharMenu.c    **** 
 235:CharMenu.c    **** void PrintScroll(uint8_t sNum, uint8_t sMax)
 236:CharMenu.c    **** {
 775               		.loc 1 236 0
 776               		.cfi_startproc
 777               	.LVL44:
 778 02a2 CF93      		push r28
 779               	.LCFI20:
 780               		.cfi_def_cfa_offset 3
 781               		.cfi_offset 28, -2
 782 02a4 DF93      		push r29
 783               	.LCFI21:
 784               		.cfi_def_cfa_offset 4
 785               		.cfi_offset 29, -3
 786               	/* prologue: function */
 787               	/* frame size = 0 */
 788               	/* stack size = 2 */
 789               	.L__stack_usage = 2
 790 02a6 C82F      		mov r28,r24
 791 02a8 D62F      		mov r29,r22
 237:CharMenu.c    **** 	LCDGotoXY(0,1);
 792               		.loc 1 237 0
 793 02aa 61E0      		ldi r22,lo8(1)
 794               	.LVL45:
 795 02ac 80E0      		ldi r24,0
 796               	.LVL46:
 797 02ae 0E94 0000 		call LCDGotoXY
 798               	.LVL47:
 238:CharMenu.c    **** 	LCDprogressBar(sNum, sMax,16);
 799               		.loc 1 238 0
 800 02b2 40E1      		ldi r20,lo8(16)
 801 02b4 6D2F      		mov r22,r29
 802 02b6 8C2F      		mov r24,r28
 803               	/* epilogue start */
 239:CharMenu.c    **** 	return;
 240:CharMenu.c    **** 	uint8_t mulai = 0;
 241:CharMenu.c    **** 	uint8_t nScroll = 1;
 242:CharMenu.c    **** 	LcdDelete(0,15,1);
 243:CharMenu.c    **** 	mulai = 8-(sMax/2);
 244:CharMenu.c    **** 	LCDGotoXY(mulai,1);
 245:CharMenu.c    **** 	for (nScroll = 1; nScroll<=sMax; nScroll++)
 246:CharMenu.c    **** 	{
 247:CharMenu.c    **** 		if (nScroll == sNum)
 248:CharMenu.c    **** 		{
 249:CharMenu.c    **** 			LCDstring((uint8_t*)"#",1);
 250:CharMenu.c    **** 		}
 251:CharMenu.c    **** 		else
 252:CharMenu.c    **** 		{
 253:CharMenu.c    **** 			LCDstring((uint8_t*)"-",1);
 254:CharMenu.c    **** 		}
 255:CharMenu.c    **** 	}
 256:CharMenu.c    **** }
 804               		.loc 1 256 0
 805 02b8 DF91      		pop r29
 806               	.LVL48:
 807 02ba CF91      		pop r28
 808               	.LVL49:
 238:CharMenu.c    **** 	LCDprogressBar(sNum, sMax,16);
 809               		.loc 1 238 0
 810 02bc 0C94 0000 		jmp LCDprogressBar
 811               	.LVL50:
 812               		.cfi_endproc
 813               	.LFE25:
 815               	.global	CharMenuDraw
 817               	CharMenuDraw:
 818               	.LFB20:
 139:CharMenu.c    **** {
 819               		.loc 1 139 0
 820               		.cfi_startproc
 821 02c0 1F93      		push r17
 822               	.LCFI22:
 823               		.cfi_def_cfa_offset 3
 824               		.cfi_offset 17, -2
 825 02c2 CF93      		push r28
 826               	.LCFI23:
 827               		.cfi_def_cfa_offset 4
 828               		.cfi_offset 28, -3
 829 02c4 DF93      		push r29
 830               	.LCFI24:
 831               		.cfi_def_cfa_offset 5
 832               		.cfi_offset 29, -4
 833               	/* prologue: function */
 834               	/* frame size = 0 */
 835               	/* stack size = 3 */
 836               	.L__stack_usage = 3
 140:CharMenu.c    **** 	if (MenuMain[gState].actFunction!=0)
 837               		.loc 1 140 0
 838 02c6 8091 0000 		lds r24,gState
 839 02ca 9091 0000 		lds r25,gState+1
 840 02ce FC01      		movw r30,r24
 841 02d0 23E0      		ldi r18,3
 842               		1:
 843 02d2 EE0F      		lsl r30
 844 02d4 FF1F      		rol r31
 845 02d6 2A95      		dec r18
 846 02d8 01F4      		brne 1b
 847 02da E050      		subi r30,lo8(-(MenuMain))
 848 02dc F040      		sbci r31,hi8(-(MenuMain))
 849 02de 0680      		ldd __tmp_reg__,Z+6
 850 02e0 F781      		ldd r31,Z+7
 851 02e2 E02D      		mov r30,__tmp_reg__
 852 02e4 3097      		sbiw r30,0
 853 02e6 01F0      		breq .L71
 142:CharMenu.c    **** 		MenuMain[gState].actFunction();
 854               		.loc 1 142 0
 855 02e8 0995      		icall
 856               	.LVL51:
 857 02ea 00C0      		rjmp .L83
 858               	.L71:
 155:CharMenu.c    **** 		if ((MenuMain[x].parentIndex == gState) && ((MenuMain[x].cursorNum) == gCursor))
 859               		.loc 1 155 0
 860 02ec 2091 0000 		lds r18,gCursor
 861 02f0 30E0      		ldi r19,0
 862 02f2 E0E0      		ldi r30,lo8(MenuMain+13)
 863 02f4 F0E0      		ldi r31,hi8(MenuMain+13)
 864 02f6 C1E0      		ldi r28,lo8(1)
 865 02f8 D0E0      		ldi r29,0
 866               	.L79:
 867 02fa 1C2F      		mov r17,r28
 868               	.LVL52:
 869 02fc 4081      		ld r20,Z
 870 02fe 50E0      		ldi r21,0
 871 0300 4817      		cp r20,r24
 872 0302 5907      		cpc r21,r25
 873 0304 01F0      		breq .+2
 874 0306 00C0      		rjmp .L73
 875 0308 DF01      		movw r26,r30
 876 030a 1597      		sbiw r26,5
 155:CharMenu.c    **** 		if ((MenuMain[x].parentIndex == gState) && ((MenuMain[x].cursorNum) == gCursor))
 877               		.loc 1 155 0 is_stmt 0 discriminator 1
 878 030c 4D91      		ld r20,X+
 879 030e 5C91      		ld r21,X
 880 0310 4217      		cp r20,r18
 881 0312 5307      		cpc r21,r19
 882 0314 01F0      		breq .+2
 883 0316 00C0      		rjmp .L73
 884               	.LBB9:
 158:CharMenu.c    **** 			LCDGotoXY(0,0);
 885               		.loc 1 158 0 is_stmt 1
 886 0318 60E0      		ldi r22,0
 887 031a 80E0      		ldi r24,0
 888 031c 0E94 0000 		call LCDGotoXY
 889               	.LVL53:
 159:CharMenu.c    **** 			LCDstring((uint8_t*)(MenuMain[x].menuText),16);
 890               		.loc 1 159 0
 891 0320 93E0      		ldi r25,3
 892               		1:
 893 0322 CC0F      		lsl r28
 894 0324 DD1F      		rol r29
 895 0326 9A95      		dec r25
 896 0328 01F4      		brne 1b
 897               	.LVL54:
 898 032a C050      		subi r28,lo8(-(MenuMain))
 899 032c D040      		sbci r29,hi8(-(MenuMain))
 900 032e 60E1      		ldi r22,lo8(16)
 901 0330 8A81      		ldd r24,Y+2
 902 0332 9B81      		ldd r25,Y+3
 903 0334 0E94 0000 		call LCDstring
 904               	.LVL55:
 160:CharMenu.c    **** 			PrintScroll(gCursor,MenuMain[MenuMain[x].parentIndex].numOfChildren);
 905               		.loc 1 160 0
 906 0338 ED81      		ldd r30,Y+5
 907 033a 88E0      		ldi r24,lo8(8)
 908 033c E89F      		mul r30,r24
 909 033e F001      		movw r30,r0
 910 0340 1124      		clr __zero_reg__
 911 0342 E050      		subi r30,lo8(-(MenuMain))
 912 0344 F040      		sbci r31,hi8(-(MenuMain))
 913 0346 6481      		ldd r22,Z+4
 914 0348 8091 0000 		lds r24,gCursor
 915 034c 0E94 0000 		call PrintScroll
 916               	.LVL56:
 163:CharMenu.c    **** 			uint8_t action = ButtonRead();
 917               		.loc 1 163 0
 918 0350 0E94 0000 		call ButtonRead
 919               	.LVL57:
 164:CharMenu.c    **** 			if (action == BUTTON_ENTER_DOWN)
 920               		.loc 1 164 0
 921 0354 8130      		cpi r24,lo8(1)
 922 0356 01F4      		brne .L74
 166:CharMenu.c    **** 				gState = x;
 923               		.loc 1 166 0
 924 0358 212F      		mov r18,r17
 925 035a 30E0      		ldi r19,0
 926 035c 3093 0000 		sts gState+1,r19
 927 0360 2093 0000 		sts gState,r18
 928 0364 00C0      		rjmp .L84
 929               	.L74:
 181:CharMenu.c    **** 			else if (action == BUTTON_NEXT_DOWN)
 930               		.loc 1 181 0
 931 0366 8330      		cpi r24,lo8(3)
 932 0368 01F4      		brne .L75
 183:CharMenu.c    **** 				gCursor++;
 933               		.loc 1 183 0
 934 036a 8091 0000 		lds r24,gCursor
 935               	.LVL58:
 936 036e 8F5F      		subi r24,lo8(-(1))
 937 0370 8093 0000 		sts gCursor,r24
 184:CharMenu.c    **** 				if (gCursor>MenuMain[MenuMain[x].parentIndex].numOfChildren)
 938               		.loc 1 184 0
 939 0374 ED81      		ldd r30,Y+5
 940 0376 98E0      		ldi r25,lo8(8)
 941 0378 E99F      		mul r30,r25
 942 037a F001      		movw r30,r0
 943 037c 1124      		clr __zero_reg__
 944 037e E050      		subi r30,lo8(-(MenuMain))
 945 0380 F040      		sbci r31,hi8(-(MenuMain))
 946 0382 9481      		ldd r25,Z+4
 947 0384 9817      		cp r25,r24
 948 0386 00F4      		brsh .L70
 185:CharMenu.c    **** 					gCursor = 1;
 949               		.loc 1 185 0
 950 0388 81E0      		ldi r24,lo8(1)
 951 038a 00C0      		rjmp .L84
 952               	.LVL59:
 953               	.L75:
 187:CharMenu.c    **** 			else if (action == BUTTON_PREV_DOWN)
 954               		.loc 1 187 0
 955 038c 8111      		cpse r24,__zero_reg__
 956 038e 00C0      		rjmp .L77
 189:CharMenu.c    **** 				gCursor--;
 957               		.loc 1 189 0
 958 0390 8091 0000 		lds r24,gCursor
 959               	.LVL60:
 960 0394 8150      		subi r24,lo8(-(-1))
 961 0396 8093 0000 		sts gCursor,r24
 190:CharMenu.c    **** 				if (gCursor<1)
 962               		.loc 1 190 0
 963 039a 8111      		cpse r24,__zero_reg__
 964 039c 00C0      		rjmp .L70
 191:CharMenu.c    **** 					gCursor = MenuMain[MenuMain[x].parentIndex].numOfChildren;
 965               		.loc 1 191 0
 966 039e ED81      		ldd r30,Y+5
 967 03a0 88E0      		ldi r24,lo8(8)
 968 03a2 E89F      		mul r30,r24
 969 03a4 F001      		movw r30,r0
 970 03a6 1124      		clr __zero_reg__
 971 03a8 E050      		subi r30,lo8(-(MenuMain))
 972 03aa F040      		sbci r31,hi8(-(MenuMain))
 973 03ac 8481      		ldd r24,Z+4
 974               	.L84:
 975 03ae 8093 0000 		sts gCursor,r24
 976 03b2 00C0      		rjmp .L70
 977               	.LVL61:
 978               	.L77:
 193:CharMenu.c    **** 			else if (action == BUTTON_BACK_DOWN)
 979               		.loc 1 193 0
 980 03b4 8230      		cpi r24,lo8(2)
 981 03b6 01F4      		brne .L70
 982               	.LVL62:
 983               	.L83:
 195:CharMenu.c    **** 				gCursor = MenuMain[gState].cursorNum;
 984               		.loc 1 195 0
 985 03b8 E091 0000 		lds r30,gState
 986 03bc F091 0000 		lds r31,gState+1
 987 03c0 83E0      		ldi r24,3
 988               		1:
 989 03c2 EE0F      		lsl r30
 990 03c4 FF1F      		rol r31
 991 03c6 8A95      		dec r24
 992 03c8 01F4      		brne 1b
 993 03ca E050      		subi r30,lo8(-(MenuMain))
 994 03cc F040      		sbci r31,hi8(-(MenuMain))
 995 03ce 8081      		ld r24,Z
 996 03d0 8093 0000 		sts gCursor,r24
 196:CharMenu.c    **** 				gState = MenuMain[gState].parentIndex;
 997               		.loc 1 196 0
 998 03d4 8581      		ldd r24,Z+5
 999 03d6 90E0      		ldi r25,0
 1000 03d8 9093 0000 		sts gState+1,r25
 1001 03dc 8093 0000 		sts gState,r24
 1002 03e0 00C0      		rjmp .L70
 1003               	.LVL63:
 1004               	.L73:
 1005 03e2 3896      		adiw r30,8
 1006 03e4 2196      		adiw r28,1
 1007               	.LVL64:
 1008               	.LBE9:
 152:CharMenu.c    **** 	for (x=1;x<TOTAL_MENU;x++)
 1009               		.loc 1 152 0
 1010 03e6 CB30      		cpi r28,11
 1011 03e8 D105      		cpc r29,__zero_reg__
 1012 03ea 01F0      		breq .+2
 1013 03ec 00C0      		rjmp .L79
 1014               	.LVL65:
 1015               	.L70:
 1016               	/* epilogue start */
 204:CharMenu.c    **** }
 1017               		.loc 1 204 0
 1018 03ee DF91      		pop r29
 1019 03f0 CF91      		pop r28
 1020 03f2 1F91      		pop r17
 1021 03f4 0895      		ret
 1022               		.cfi_endproc
 1023               	.LFE20:
 1025               		.comm	MenuMain,88,1
 1026               		.comm	gScrollMax,1,1
 1027               		.comm	gCursor,1,1
 1028               		.comm	gState,2,1
 1029               	.Letext0:
 1030               		.file 3 "/usr/lib/avr/include/stdint.h"
 1031               		.file 4 "CharMenu.h"
 1032               		.file 5 "/usr/lib/gcc/avr/4.8.2/include/stddef.h"
 1033               		.file 6 "lcd_lib.h"
 1034               		.file 7 "/usr/lib/avr/include/stdio.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 CharMenu.c
     /tmp/ccTP5sbB.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccTP5sbB.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccTP5sbB.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccTP5sbB.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccTP5sbB.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccTP5sbB.s:18     .text:0000000000000000 DrawNumber
     /tmp/ccTP5sbB.s:175    .text:00000000000000b2 DrawNumberCPos
     /tmp/ccTP5sbB.s:308    .text:0000000000000148 LcdDelete
     /tmp/ccTP5sbB.s:361    .text:000000000000016e ButtonEnter
     /tmp/ccTP5sbB.s:382    .text:000000000000017a ButtonBack
     /tmp/ccTP5sbB.s:404    .text:0000000000000188 ButtonNext
     /tmp/ccTP5sbB.s:426    .text:0000000000000196 ButtonPrev
     /tmp/ccTP5sbB.s:445    .text:000000000000019e ButtonWait
     /tmp/ccTP5sbB.s:472    .text:00000000000001b0 ButtonIsPressed
     /tmp/ccTP5sbB.s:503    .text:00000000000001c8 ButtonIsNotPressed
     /tmp/ccTP5sbB.s:533    .text:00000000000001de ButtonRead
     /tmp/ccTP5sbB.s:595    .text:0000000000000210 CharMenuInit
                            *COM*:0000000000000058 MenuMain
     /tmp/ccTP5sbB.s:635    .text:0000000000000244 CharMenuRelink
     /tmp/ccTP5sbB.s:665    .text:0000000000000258 GetCursor
     /tmp/ccTP5sbB.s:691    .text:0000000000000268 GetParent
     /tmp/ccTP5sbB.s:723    .text:000000000000027e GetChild
     /tmp/ccTP5sbB.s:746    .text:000000000000028a ReStrainScroll
                            *COM*:0000000000000001 gCursor
                            *COM*:0000000000000001 gScrollMax
     /tmp/ccTP5sbB.s:773    .text:00000000000002a2 PrintScroll
     /tmp/ccTP5sbB.s:817    .text:00000000000002c0 CharMenuDraw
                            *COM*:0000000000000002 gState

UNDEFINED SYMBOLS
LCDGotoXY
LCDstring
snprintf
__udivmodhi4
LCDprogressBar
__do_copy_data
__do_clear_bss
